# [SWEA]프로그래밍과 논리/수학

**목적**

- Problem Solving에 필요한 기초 논리와 수학 학습
- 논리적으로 정확하게 확인하는 훈련을 하여, 프로그램을 짜기 시작하기 전에, 정확한 결과가 나올 것인지, 얼마나 빠르게 돌아갈 것인지 미리 알기 위함

## 논리와 증명

### **논리**

- Hard Logic(논리) vs Soft Logic(직관)

직관은 논리적인 **느낌**을 주는 것

직관의 장점은 (익숙한 상황에서) 빠르다는 것

직관의 단점은 정확하지 않다는 것, 강한 착각을 일으킨다는 것

- Inclusive vs Exclusive

ex) 같은 표현을 사용하지만 논리적으로는 다른 예

합격하려면 토플500점이상 **혹은** 토익 600점이상 필요(inclusive or)

복권에 당첨되면 자동차 **혹은** 천만원을 준다.(exclusive or)

### **명제**

`p거짓 → q는 항상 참이 된다.`

가정이 거짓이라면 전체는 항상 참이 된다.

- 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다. (참)
    
    0은 홀수가 아니므로. 가정이 거짓이니까.
    
- 100점 맞으면 치킨 사줄게.
    - 100점 맞았는데 치킨 사준다.(참)
    - 100점 맞았는데 치킨 안 사준다. (거짓)
    - 80점 맞았는데 치킨 사준다.(참)

`p연관관계없음 → q진실은 항상 참이 된다.`

가정과 무관하게 뒤쪽이 참이기 때문에 전체는 항상 참이 된다.

- Q1)만약 19392390592305809239이 Prime Number라면, 2는 짝수이다.(참)
- Q2)p와 q가 명제이고 p→q가 거짓이다. 다음 명제식의 참 거짓은?
    
    → 즉, p는 참이고 q가 거짓이다.
    
    `~p → q` (참), `p v q`(참),  `q → p`(참) [v는 or임]
    
- Q3)역, 이, 대우 쓰기
    
    **역 : `p → q` ⇒ `q → p`**
    
    **이 : `p → q` ⇒ `~p → ~q`**
    
    **대우: `p → q` ⇒ `~q → ~p`**
    
    [만약 0이 홀수라면, 미국에서 2080년 월드컵 열린다.]
    
    - **역**: 만약 미국에서 2080년 월드컵 열린다면 0이 홀수이다.
    - **이**:만약 0이 홀수가 아니라면, 미국에서 2080년 월드컵이 열리지 않는다.
    - **대우**: 만약 미국에서 2080년 월드컵이 열리지 않는다면 0이 홀수가 아니다.
- Q4) 명제식의 진리표 만들기 [^는 &임]

| p q | p ^ (q→~p) | 풀이 |
| --- | --- | --- |
| T T | 참 ^ (참→ 거짓) | 참^거짓 = F |
| T F | 참 ^ (거짓→무관) | 참^참 = T |
| F T | 거짓 ^ 무관 | F |
| F F | 거짓 ^ 무관 | F |

### **증명**

증명은 정확한 **명제식으로 표현할 수 있는 것이어야** 함

증명에 대한 수많은 오해가 p→q를 p↔q와 혼동하는 것에서 일어남

- **수학적 귀납법**
    - 수학적 귀납법의 기본형 : P(1)이 참이고, P(n) → P(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참이다.
    - 수학적 귀납법의 강한 형태 : P(1)이 참이고, P(1)^P(2)^…^P(n) → P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.

Q1)다음 함수가 1부터 x까지의 합을 계산함을 증명해보자.

```python
int sum(int x)
{
	if (x <= 0) return 0;
	return x + sum(x-1);
}
```

**증명이 가능한 명제를 만들어야 함**

[ sum(x)가 리턴하는 값은 1+2+…+x의 값과 항상 같다. ]

**수학적 귀납법 적용**

- `P(1)이 참이다`: sum(1)이 리턴하는 값은 1이다를 증명.
    - 코드에 1을 대입하면 1을 리턴함을 알 수 있다.
- `p(x)→p(x+1)이 참이다`: **“sum(x-1)이 1+2+…+(x-1)을 리턴하면 sum(x)는 1+2+…+x를 리턴한다”**를 증명하면 됨.
- 코드를 보면 sum(x)는 x +sum(x-1)의 값을 리턴함. sum(x-1)의 리턴 값은 1+2+…+(x-1)과 같다고 가정했으므로 sum(x)는 1+2+…+(x-1)+x =1+2+….+x를 리턴함을 확인할 수 있음

Q2)버블 소트의 증명

- 배열 A[1], A[2],…,A[n]을 정렬하는 알고리즘의 정확성을 증명하려고 한다면, 증명이 가능한 명제는 A[1] < A[2] < … < A[N]