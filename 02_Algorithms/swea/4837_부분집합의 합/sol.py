# 1부터 12까지의 숫자를 원소로 가진 집합 A가 있다.
# -> 2 ** 12가 12개의 원소를 가지고 만들 수 있는 부분 집합의 경우의 수
# -> 4096개의 경우의 수를 가진 부분 집합들을 우선 만들고 그 중 조건에 맞는 것만 카운트하자.
# -> -> 원소의 수만큼 비트를 비교해서 원소 포함할지 안할지 선택
# -> 각 자리마다 원소가 들어갈지 아닐지를 어떻게 ? 비트쉬프트연산 0 1 & i번째 수의 2진법으로 각각 비교
# 집합 A의 부분 집합 중 N개의 원소를 갖고 있고, 원소의 합이 K인 부분 집합의 개수를 출력
# -> len(부분집합리스트) == N개 & sum(부분집합리스트) == K인 것을 count해서 cnt 출력
# 해당하는 부분집합이 없는 경우 0을 출력.
# -> 만약 cnt가 0이면 0 출력됨
# --> 개선 가능한 점 - 모든 경우의 수의 부분집합 만들지 않고 주어진 개수의 원소만 들어올 부분집합을 만들 수 있는 방법으로 할 수 있을까?
import sys
sys.stdin = open('input.txt')

T = int(input())

for tc in range(1, T+1):
    N, K = (map(int, input().split()))  # 부분 집합 원소 개수, 원소의 합
    cnt = 0
    a_set = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # 주어진 집합
    n = len(a_set)  # 집합의 원소 수

    for i in range(2**n):  # 4096행. 원소가 n개일 경우 생성 가능한 모든 부분 집합의 개수
        subset = []  # 부분 집합 원소 담을 리스트 준비
        for j in range(n):  # 원소.열 / 원소의 수만큼 비트를 비교. 원소 포함 여부 판단
            if i & (1 << j):  # i의 j번째 비트가 1이면 j번째 원소를
                subset.append(a_set[j])  # subset리스트에 추가
        if len(subset) == N and sum(subset) == K:  # 완성된 부분집합의 원소개수가 N이며 원소합이 K일 경우
            cnt += 1  # 카운트

    print(f'#{tc} {cnt}')  # 최종 카운트 출력
