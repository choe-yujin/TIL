# **그룹 프로그래밍**

## swea 4837_부분집합의 합

**2022년 12월 27일 10시~16시**

인원 : 4인

장소 : 게더타운



**문제 분석**

1부터 12까지의 숫자를 원소로 가진 집합 A가 있다.

집합 A의 부분 집합 중 N개의 원소를 갖고 있고, 원소의 합이 K인 부분 집합의 개수를 출력

- > 집합A [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
- > 예를 들어 N = 3, K = 6 경우, 부분집합은 { 1, 2, 3 } 경우 1가지가 존재한다.
- > len(부분집합리스트) == N개 & sum(부분집합리스트) == K인 것을 count해서 cnt 출력

**접근 방식 설명**

모든 부분 집합 리스트를 우선 만들자. 

`2**12`  12개의 원소를 가지고 만들 수 있는 부분 집합의 경우의 수

4096개의 경우의 수를 가진 부분 집합들 중 조건에 맞는 것만 카운트하자.

- > 원소의 수만큼 비트를 비교해서 원소 포함할지 안 할지 선택
- > 각 자리마다 원소가 들어갈지 아닐지를 어떻게 ? 비트 연산 0 1 & i번째 수의 2진법으로 각각 비교

**코드로 설명**

```python
import sys
sys.stdin = open('input.txt')

T = int(input())

for tc in range(1, T+1):
    N, K = (map(int, input().split()))  # 부분 집합 원소 개수, 원소의 합
    cnt = 0
    a_set = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # 주어진 집합
    n = len(a_set)  # 집합의 원소 수

    for i in range(2**n):  # 4096행. 원소가 n개일 경우 생성 가능한 모든 부분 집합의 개수
        subset = []  # 부분 집합 원소 담을 리스트 준비
        for j in range(n):  # 원소.열 / 원소의 수만큼 비트를 비교. 원소 포함 여부 판단
            if i & (1 << j):  # i의 j번째 비트가 1이면 j번째 원소를
                subset.append(a_set[j])  # subset리스트에 추가
        if len(subset) == N and sum(subset) == K:  # 완성된 부분집합의 원소개수가 N이며 원소합이 K일 경우
            cnt += 1  # 카운트

    print(f'#{tc} {cnt}')  # 최종 카운트 출력
```

```python
# a_set = [1, 2, 3]일 경우로 눈으로 확인해 본 비트연산
for i in range(2 ** 3):  # 부분 집합 총 8개
subset = []  # 부분 집합 원소 담을 리스트 준비
for j in range(3):  
    if i & (1 << j):  # i의 j번째 비트가 1이면 j번째 원소를
        subset.append(a_set[j])  # subset리스트에 추가
print(subset)
                                 i     1<<j    집합
i:0, j:0, 1<<j: 1   0 & 1  F [0,0,0] [0,0,1] [1,2,3]
i:0, j:1, 1<<j: 2   0 & 2  F [0,0,0] [0,1,0] [1,2,3]
i:0, j:2, 1<<j: 4   0 & 4  F [0,0,0] [1,0,0] [1,2,3]
[]                               i     1<<j    집합
i:1, j:0, 1<<j: 1   1 & 1  T [0,0,1] [0,0,1] [1,2,3]
i:1, j:1, 1<<j: 2   1 & 2  F [0,0,1] [0,1,0] [1,2,3]
i:1, j:2, 1<<j: 4   1 & 4  F [0,0,1] [1,0,0] [1,2,3] j:0번째
[1]                              i     1<<j    집합
i:2, j:0, 1<<j: 1   2 & 1  F [0,1,0] [0,0,1] [1,2,3]
i:2, j:1, 1<<j: 2   2 & 2  T [0,1,0] [0,1,0] [1,2,3]
i:2, j:2, 1<<j: 4   2 & 4  F [0,1,0] [1,0,0] [1,2,3] j:1번째
[2]                              i     1<<j    집합
i:3, j:0, 1<<j: 1   3 & 1  T [0,1,1] [0,0,1] [1,2,3]
i:3, j:1, 1<<j: 2   3 & 2  T [0,1,1] [0,1,0] [1,2,3]
i:3, j:2, 1<<j: 4   3 & 4  F [0,1,1] [1,0,0] [1,2,3]j:0,1번째
[1, 2]                           i     1<<j    집합
i:4, j:0, 1<<j: 1   4 & 1  F [1,0,0] [0,0,1] [1,2,3]
i:4, j:1, 1<<j: 2   4 & 2  F [1,0,0] [0,1,0] [1,2,3]
i:4, j:2, 1<<j: 4   4 & 4  T [1,0,0] [1,0,0] [1,2,3]j:2번째
[3]                              i     1<<j    집합
i:5, j:0, 1<<j: 1   5 & 1  T [1,0,1] [0,0,1] [1,2,3]
i:5, j:1, 1<<j: 2   5 & 2  F [1,0,1] [0,1,0] [1,2,3]
i:5, j:2, 1<<j: 4   5 & 4  T [1,0,1] [1,0,0] [1,2,3]j:0,2번째
[1, 3]                          i     1<<j    집합
i:6, j:0, 1<<j: 1   6 & 1  F [1,1,0] [0,0,1] [1,2,3]
i:6, j:1, 1<<j: 2   6 & 2  T [1,1,0] [0,1,0] [1,2,3]
i:6, j:2, 1<<j: 4   6 & 4  T [1,1,0] [1,0,0] [1,2,3]j:1,2번째
[2, 3]                          i     1<<j    집합
i:7, j:0, 1<<j: 1   7 & 1  T [1,1,1] [0,0,1] [1,2,3]
i:7, j:1, 1<<j: 2   7 & 2  T [1,1,1] [0,1,0] [1,2,3]
i:7, j:2, 1<<j: 4   7 & 4  T [1,1,1] [1,0,0] [1,2,3]j:0,1,2번째
[1, 2, 3]
```



**배운점**

- 있다 없다를 처리하기 위해 1, 0 비트연산과 시프트 연산에 대해 공부할 수 있었다. 
- `1 << n`   00**1 **   0**1**0   **1**00     2진법 1을 n만큼 왼쪽으로 이동. 
  - (주어진 수가 3이라면 011 을 이동하게 됨)

- 사람 눈에는 숫자가 10진법으로 보이지만 그 숫자는 & | 연산을 할 경우엔 2진법으로 한다. 이게 직관적이지 않아서 일일이 하나하나 만들어서 비교해보았다. 

  - 1 0 1      1 0 1     1 0 1       10진 숫자     5 

  - 0 0 1      0 1 0     1 0 0       10진 숫자 1, 2, 4

  -   &             &           &

  - 0 0 1      0 0 0     1 0 0        

  - 1 T           0 F         4 T      


- `filter`와 `lambda`는 배웠지만 코드 짤 때 많이 응용해보지 못하는데 주용님은 filter와 lambda를 가지고 간결하게 counting하고 sum을 했다.

  ```python
  # lst 안에있는 부분집합 중 원소개수N만 필터
  lst_N = list(filter(lambda e: len(e) == N, lst))  
  
  # 합이 K인 부분집합을 카운트
  cnt = len(list(filter(lambda e: sum(e) == K, lst_N)))  
  ```



**개선할점**

2**12개나 만들어서 조건을 비교했는데 모든 경우의 수의 부분 집합 만들지 않고 주어진 개수의 원소만 이용해 부분 집합을 만들 수 있는 방법은 없을까? `import combinations`를 활용할 수 있다.

원하는 원소 개수만 가지고 부분집합을 만들어 볼 수 있다.

```python
# combinations import해서 사용한 강사님 코드
from itertools import combinations

numbers = [1, 2, 3, 4, 5]
list(combinations([1, 2, 3, 4], 2))

for i in range(1, len(numbers)+1):
    for comb in combinations(numbers, i):
        if sum(comb) == 6:
            print(comb)
```



**느낀점**

`if i & (1 << j):` 이 코드가 내부에서 어떻게 돌아갈지 하나하나 수동 디버그 해가며 풀어봤는데 막상 발표하려고 하니 숫자의 &연산을 설명하는데에서 버벅댔다. 그래서 발표가 끝나고 정리하면서 다시 한번 리뷰해보았다. 4인 그룹 프로그래밍인데 참여 하는 분도 있고 하지 않는 분도 있었다. 온라인이라서 참여를 독려하기도 어려웠다. 레벨에 비해 너무 어려운 문제가 주어져서 2명밖에 풀지 못해서 코드를 여러개 비교해볼 수도 없었다. 다음에는 문제 접근방식을 말로 푼 다음에 써볼만한 import 툴이 있을지 강사님께 여쭤보는 것도 하나의 방법이 될 것 같다. `combinations`를 이전에 접해봤다면 배경 지식이 있어서 사용할 수 있었을텐데 백지상태라 의식의 흐름대로 코드를 짤 수 밖에 없었다. 하지만 4시간 넘게 끙끙대던 그 과정에서 많은 지식을 체화할 수 있었다.
