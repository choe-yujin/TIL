# **그룹 프로그래밍**

## SWEA_1979. 어디에 단어가 들어갈 수 있을까

**2022년 12월 28일 11시~16시**

인원 : 4인

장소 : 게더타운



### 문제 분석

- N X N 크기의 단어 퍼즐의 모양이 주어짐

  - 흰색 부분은 1 검정색 부분은 0으로 채워짐
  - 흰색 부분에 단어가 들어갈 수 있다.

- 퍼즐의 가로, 세로 길이인 N 과, 단어 길이인 K가 주어짐

  - NXN 로 주어진 퍼즐 모양도 줬는데 N은 왜 따로 또 줬을까 ?

    아… input.txt에서 입력 받을 때 N만큼 자르라고…

⇒ 주어진 퍼즐 모양에서 특정 길이 K를 갖는 단어가 들어갈 수 있는 자리의 개수를 출력하라!



### 접근법

- 사람은 3차원에서 위에서 내려다보니 빈칸이 한눈에 보여 셀 수 있지만 NXN퍼즐 입장에서는 2차원이기때문에 한 자리에서 양옆과 앞뒤밖에 볼 수 없다.

- 그러니 단어가 들어갈 수 있는 자리의 길이를 이동할 방향으로 한칸씩 이동하며 재야 한다.

  - 시작 부분에서 연속으로 1인 부분을 cnt해나가다가 끝나는 부분에서 cnt멈추고

    그 cnt == 단어 길이(K)의 조건에 맞다면 단어가 들어갈 수 있는 자리 개수를 cnt해둔다.

    (cnt변수 2개 필요. 단어 길이 용도의 cnt, 조건에 맞는 단어 개수 용도의 cnt)

- 방향 문제. 1이 연속되는 자리의 경우는 가로도 있고 세로도 있다.

  - 가로일 경우와 세로일 경우를 한번에 모두 고려하는 알고리즘을 짜는 것은 어려울 것 같다.
  - 가로일 경우의 알고리즘만 짜두고  퍼즐을 뒤집어서 세로를 가로로 만들어두고 동일한 알고리즘을 적용해 또 카운트 해야겠다.

  ------

- 자, 그럼! 순서대로 가로로 세 나가기(행 길이만큼 아래 작업을 반복) for r in 행

  - 행에서 요소 체크하는 루프. for c in range(r)

    내 idx가 N-K(가로 길이 - 단어 길이)보다 작아지면 1이 나와도 셀 필요가 없다.

    (N-K까지 한번도 카운트가 안됐다면 그냥 다음 루프로 가게 할 수도 있다.)

    ex) N=5, K=3인 경우 [0 0 0 1 1] 이라면 idx3부터는 길이 세는 게 무의미하다. N-K (5-3=2) idx가 2일때까지 1이 안 나온다면 더 체크하지 말고 다음 행으로 넘어간다.

  - 첫 번째 행의 첫 열에서 시작해 값이 1인지 0인지 체크한다. 1인 값을 만나면 cnt돌입.

  - 카운트 하다가 0인 값을 만나면 K길이랑 cnt가 일치하는지 조건 확인하고 조건 일치시 단어 자리 개수 카운트 +1해둔다. 단어 길이 재던 cnt는 0으로 리셋해준다.

  - 그리고 다음 요소 값이 1인지 또 체크해나감. (위 작업 반복.)

    ex) [1110011100] 이면 idx0과 idx5에서 cnt start 두 번 하게 됨. idx3과 idx8에서 cnt reset함

- 주어진 퍼즐 세트의 열(세로)을 행(가로)으로 바꿔서 또 가로로 세나가기(위 작업 반복)

- 최종 단어 자리 수 카운트를 출력한다.  끄읏.

  

### 코드

- 필요 변수 : 단어 길이 용도의 cnt, 조건에 맞는 단어 개수 용도의 cnt

```python
T = int(input())

for tc in range(1, T+1):
    N, K = map(int, input().split())
    ans = 0  # 단어 자리 개수 카운트용
    puzzle = [] 
    for _ in range(N):
        puzzle.append(list(map(int, input().split())))  # 받아 오기
    
    def K_check(puzzle_set):  # 똑같은 작업 퍼즐셋 두번 할꺼라 함수화 함
        global ans  # 아래 ans +=1에서 변수 인식 못하길래 global ans라고 정의해 줌
        for r in puzzle_set:
            cnt = 0  # 단어 길이 카운트용
            for i in range(N):
                if r[i] == 1:
                    cnt += 1
                elif r[i] == 0:
                    if cnt == K:  # 0으로 끝날때도 다음 단어 길이 재러가기 전 cnt==K조건 확인
                        ans += 1  
                    cnt = 0
            if cnt == K:
                ans += 1  # 0 만나지 않았으면 cnt==K 체크 아직 못했으니 다음 루프가기전에도 조건 확인
    
    K_check(puzzle)  # 오리지날 퍼즐
    rotated_puzzle = list(zip(*puzzle))
    K_check(rotated_puzzle)  # 열을 행으로 바꾼 퍼즐

    print(f'#{tc} {ans}')

```



**느낀점**

- 문제의 의도는 2차원 배열에서 세로로 값에 접근해서 카운트 하는 것을 연습해보자는 것이었을텐데 나는 너무 꼼수를 부려서 zip함수로 가로로 돌려놓고 셌다. 그래서 발표 후 연습 겸 현민님처럼 세로방향으로 세 나가는 코드도 다시 짜봤다. 

- 내가 코드에 어떻게 접근했는지 문제를 분석한 것을 글로 길게 적어뒀는데 이를 남에게 설명할 때는 시각화해서 간결하고 명확하게 전달하는 스킬이 무엇보다 중요할 것 같다. 핵심만 !



**배운점**

- 현민님은 똑같은 로직의 for문에서 row col 위치만 바꿔서 [row] [col] -> [ col ] [ row ] 그 아래에 또 붙여넣어서 세로를 세게 했다.
- 이중 for문의 elif문에서 `cnt==K` 체크하던 걸 for문 끝날때도 체크해줬어야해서 코드가 반복이 됐는데 화정님은 elif에 인덱스가 N-1이라면이라는 조건을 or로 줘서 반복되는 코드를 없앨 수 있게 했다.



**개선할 점**

cnt가 0이면서 내 idx가 N-K(가로 길이 - 단어 길이)보다 작아지면 1이 나와도 세는게 무의미하다. 

이 로직을 더 추가 구현하면 의미 없는 루프를 조금 줄일 수 있을 것 같다. (하지만 매번 인덱스가 N-K인지와 cnt가 0인지 체크해야하니 더 연산을 많이 하게 되려나?)
